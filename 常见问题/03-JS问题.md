## 一 JS常见问题
#### 1.1 计算精度
```js
console.log(0.4 * 0.2); //结果为 0.08000000000000002
console.log((0.4 * 10) * (0.2 * 10) / 100); //0.08
```
#### 1.2 伪数组
伪数组（类数组）：无法直接调用数组方法，但可以按照数组遍历方法来遍历它们。  
案例：函数的argument参数，getElementsByTagName,document.childNodes之类的。  
转换：使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。  
如果要让为数组直接执行数组对象的方法，可以使用call。  
#### 1.3  substring、substr、slice
```
substring(start,end);
slice(start,end);           //推荐使用，因为允许负数

substr(start,length);		//不推荐，不是ECMA官方API
```
#### 1.4 清除空格trim函数
不是所有浏览器都支持trim函数，所以需要兼容方法：
```js
if (!String.prototype.trim){   
    String.prototype.trim = function () { 
        return this.replace(/(^[\s\n\t]+|[\s\n\t]+$)/g, "");
    }     
}
```
#### 1.5 calle和caller
caller：fn.caller，返回一个对函数的引用，该函数调用了当前函数；  
callee：arguments.callee，获得当前函数的引用。  
案例：
```js
// 如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）
var result=[];
function fn(n){  //典型的斐波那契数列
    if(n==1){
        return 1;
    }else if(n==2){
        return 1;
    }else{
        if(result[n]){
            return result[n];
        }else{
            //argument.callee()表示fn()
            result[n]=arguments.callee(n-1)+arguments.callee(n-2);
            return result[n];
        }
    }
}
```
#### 1.6 defineProperty, hasOwnProperty, propertyIsEnumerable
Object.defineProperty(obj, prop, descriptor)用来给对象定义属性  
Object.hasOwnProerty用于检查某一属性是不是存在于对象本身(非继承) 
propertyIsEnumerable用来检测某一属性是否可遍历，也就是能不能用for..in循环来取到.


## 二 常见理论问题
#### 2.1 对于AMD和CommonJS的比较和看法
#### 2.2 描述一种JavaScript memoization(避免重复运算)的策略
#### 2.3 严格模式
严格模式："use strict";  
```
全局变量显式声明
静态绑定
禁止使用with语句
eval中定义的变量都是局部变量
禁止this关键字指向全局对象
禁止在函数内部遍历调用栈
严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除
正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。
严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。
严格模式下，对禁止扩展的对象添加新属性，会报错。
严格模式下，删除一个不可删除的属性，会报错。
正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。
正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。
正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。
不允许对arguments赋值
arguments不再追踪参数的变化
禁止使用arguments.callee
严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数
严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。
```
#### 2.3 javascript多人开发函数重名问题
使用匿名函数；  
使用类，将每个开发人员的函数封装到类中，调用的时候就调用类的函数，即使函数重名只要类名不重复就ok





